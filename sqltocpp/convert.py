from __future__ import unicode_literals
import re
import jinja2
import os


def _sql_to_dict(sql):
    """
    Returns a dict with name and members of a create table sql statement
    """

    #mapping SQL names to CPP types
    sql_to_ctype = {
            'INTEGER': 'int',
            'REAL': 'double',
            'TEXT': 'std::string',
            'BLOB': 'std::string'
            }

    #get table name
    match_tablename = re.match('\s*CREATE TABLE\s+(\S+)', sql, re.MULTILINE)
    if match_tablename == None:
        raise Exception('No CREATE TABLE found in string:', sql)

    tablename = match_tablename.group(1)

    #loop through each definnition
    #convert SQL definition to struct
    regex_column = r'\s*\(?(\S+)\s+((?:INTEGER)|(?:REAL)|(?:TEXT)|(?:BLOB))'
    members = []
    for (name, sql_type) in re.findall(regex_column, sql, re.IGNORECASE):
        c_type = sql_to_ctype[sql_type.upper()]
        members.append({'name': name, 'c_type': c_type})

    return {'name': tablename, 'members': members}



def table_to_sql_callback(sql):
    """ 
    Turns a sql create table into a callback for C sqlite3 api
    """

    j2 = jinja2.Environment(trim_blocks=True, lstrip_blocks=True)
    callback_template = j2.from_string('''
int sql_callback(void *pArg, int argc, char **text, char **columnName)
{
    if (!columnName)
        return -1;

    if (!text)
        return -2;

    auto * list = (std::vector<{{ name }}>*) pArg;
    {{ name }} temp;
    string column(columnName);
    stringstream value;
    value.str(text);

    {% for column in columns %}
    if (column == "{{column}}")
        {{ name }}.{{column}} << value;
    {% endfor %}

    return 0;
}
''')

    sql_dict = _sql_to_dict(sql)
    columns = [ column['name'] for column in sql_dict['members'] ]
    return callback_template.render({"name": sql_dict['name'], "columns": columns })
    



def table_to_struct(sql):
    """
    Takes a SQL table schema defined as a text
    and returns a text of a C structure to represent it
    """


    # Setup jinja to not insert excess newlines
    j2 = jinja2.Environment(trim_blocks=True, lstrip_blocks=True)
    struct = j2.from_string('''
struct {{ name }}
{
    {% for member in members %}
    {{member.c_type}} {{ member.name }};
    {% endfor %}
};

''')

    return struct.render(_sql_to_dict(sql))


def map_tablename_to_sql(sql):
    """
    Returns an array of dictionaries that map each tablename to its sql
    """
    regex = r'(CREATE TABLE\s+(\S+)\s+[^;]+;)'

    tables_with_sql = []
    for (sql, tablename) in re.findall(regex, sql, re.MULTILINE):
        tables_with_sql.append({
            'tablename': tablename,
            'sql': sql
            })

    return tables_with_sql

def schema_to_struct(schema_file, location='schema.hpp'):
    """
    Reads a schema file and outputs a cpp header into location
    """
    with open(schema_file, 'r') as f:
        schema = f.read()

    tablename_list = map_tablename_to_sql(schema)
    struct_list = []
    for sql_dict in tablename_list:
        table = table_to_struct(sql_dict['sql'])
        struct_list.append(table)


    try:
        os.remove(location)
    except OSError:
        pass

    with open(location, 'w') as header:
        header.write('// Generated by SqlToCpp\n\n')
        header.write('#include <string>\n')
        header.writelines(struct_list)







